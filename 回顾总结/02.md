# token持久化

1. 为什么要进行持久化
   基于vuex的存储页面刷新token丢失

2. 如何来做
   1. 在获取到token之后 一式两份  vuex + cookie(ls)
   2. Vuex初始化state的时候 优先从本地取 取不到才初始化为空

  
3. vuex vs cookie
   vuex - 基于内存  快 刷新就丢
   cookie - 基于磁盘 稍慢 持久化

# 请求头添加token（请求拦截器）

1. 为什么要做
   接口鉴权 

2. 怎么做
   请求拦截器中统一配置  headers.Authorization = token(格式以后端要求的为主)


# 记住我优化

1. 基础实现逻辑
  如果当前用户选中了记住，在登录时把用户的信息存入本地 在组件初始化的时候去取数据 回填
  如果当前没有选中，在登录时把数据清空


# 接口错误统一处理

1. 为什么统一处理
  很多个接口都需要做这个事儿
  而且报错的提示位置和字段和后端协商好的

2. 如何来做
  axios响应拦截器来做 判断错误信息存在 弹框提示

# token是否存在控制路由权限跳转

1. 根据流程图 -> js分支语句
2. permission.js 
   1. 权限相关的事儿都放到这里 模块化的思想
   2. 路由权限前置守卫
   3. main.js引入立刻执行


# 数据基础渲染
1. 基础实现逻辑
   1. 准备静态模版（elementUI）
   2. 解决初始报错 在data中把模版绑定的数据都声明一遍
   3. 封装接口（url/ method / 参数[名称 + 类型 + 参数数量]）
   4. 组件中封装一个独立的方法 在方法中调用接口函数 （复用的好处 调用之前做一些额外的参数处理）
   5. 选择一个合适生命周期钩子函数调用独立的方法 （created / mounted 都可以）
   6. 使用数据渲染模版 （数据驱动视图）


